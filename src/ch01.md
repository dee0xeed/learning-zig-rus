
# Обзор языка. Часть I

Язык программирования Zig это компилируемый язык со строгой статической типизацией.
Он поддержтвает обобщённые структуры данных, имеет мощные средства метапрограммирования.
Управление памятью в Zig ручное, то есть в нём нет сборки мусора.
Многие люди считают Zig современной альтернативой языку C, из которого
Zig позаимствовал символ `;` как символ, завершающий инструкции (statements),
а также фигурные скобки как разграничители блоков кода.

Вот так выглядит исходный код на языке Zig:

```zig
const std = @import("std");

// Если тут убрать слово 'pub', то этот код не откомпилируется
pub fn main() void {
    const user = User{
        .power = 9001,
        .name = "Пётр",
    };

    std.debug.print("{s} обладает силой {d}\n", .{user.name, user.power});
}

pub const User = struct {
    power: u64,
    name: []const u8,
};
```

Сохраните этот исходный текст в файл с именем `ex-ch01-01.zig` и запустите его следующим образом:

```
zig run ex-ch01-01.zig 
```

Вы должны увидеть

```
Пётр обладает силой 9001
```

Этот пример достаточно простой, чтобы более-менее понять его, даже если Вы раньше
никогда не видели исходных текстов на языке Zig. Тем не менее, далее мы разберём его построчно.

## Импортирование библиотек

Редко когда бывает, что исходные тексты программы содержатся в одном-единственном файле
и при этом программа не использует никакие библиотеки. Наша первая программа также не
является исключением - она использует стандартную библиотеку Zig для того, чтобы напечатать
строчку, которую мы только что видели. Система импорта/экспорта в Zig достаточно проста
и базируется на 2-х вещах

* `@import` - это встроенная в компилятор функция
* `pub` - ключевое слово для экспортирования чего-то 

При импортировании модуля нужно указать его имя. Стандартная библиотека Zig доступна
по имени `std`. Чтобы импортировать какой-то конкретный файл, нужно использовать
путь относительно того файла, в котором делается имортирование. Например, мы могли
бы поместить описание структуры `User` в отдельный файл (скажем, `models/user.zig`)
и тогда бы в основном файле мы бы написали

```zig
const User = @import("models/user.zig").User;
```

При этом эта структура должна быть помечена как `pub`, в противном случае мы получим
ошибку компиляции, в которой будет сказано, что эта структура не является публичной.

Наш гипотетический `models/user.zig`, помимо структуры `User`, может экспортировать
и другие вещи. Например, мы могли бы также экспортировать константу:

```zig
// models/user.zig
pub const MAX_POWER = 100_000;

pub const User = struct {
    power: u64,
    name: []const u8,
};
```

И тогда бы могли в главном файле имортировать обе сущности:

```
const user = @import("models/user.zig");
const User = user.User;
const MAX_POWER = user.MAX_POWER;
```

Скорее всего, на данный момент у Вас больше вопросов, чем ответов.
Что такое `user` в приведенном отрывке? Хотя мы ещё не знакомы с ключевым
словом `var`, но тем не менее можно спросить, а что если вместо `const`
использовать `var`? Или. возможно, у Вас возник вопрос по поводу использования
сторонних библиотек. Это всё хорошие вопросы, но чтобы ответить на них,
нам нужно глубже изучить Zig, а пока нам придётся смириться с тем, что мы уже 
знаем: 

* как импортировать стандартную библиотеку (`const std = @import("std");`)
* как импортировать свои собственные файлы (`const user = @import(models/user.zig)`)
* как экспортировать те или иные определения (`pub const ...`)

## Комментарии

```
// Если тут убрать слово 'pub', то этот код не откомпилируется
```

В Zig нет многострочных комментариев в стиле C (`/* ... */`), но зато есть 3 различных
вида однострочных:

* `//` - обычные комментарии в стиле C++
* `//!` - комментарии "верхнего уровня", размещаются в начале файла
* `///` - документирующие комментарии, располагаются перед определениями

## Функции

После комментария в нащем примере идёт строчка

```zig
pub fn main() void {
```

Это начало главной функции программы. В каждом исполнимом файле должна существовать
функция, с которой начинается выполнение, это входная точка программы. Если переименовать
`main` во что-то другое, например, в `doIt` и попытаться запустить нашу
программу, то мы получим сообщение об ошибке, в котором говорится, что в нашем
файле нет функции `main`:

```
/opt/zig-0.11/lib/std/start.zig:559:45: error: root struct of file 'ex-ch01-01' has no member named 'main'
```
