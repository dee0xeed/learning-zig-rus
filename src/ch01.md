
# Обзор языка. Часть I

Язык программирования Zig это компилируемый язык со строгой статической типизацией.
Он поддержтвает обобщённые структуры данных, имеет мощные средства метапрограммирования.
Управление памятью в Zig ручное, то есть в нём нет сборки мусора.
Многие люди считают Zig современной альтернативой языку C, из которого
Zig позаимствовал символ `;` как символ, завершающий инструкции (statements),
а также фигурные скобки как разграничители блоков кода.

Вот так выглядит исходный код на языке Zig:

```zig
const std = @import("std");

// Если тут убрать слово 'pub', то этот код не откомпилируется
pub fn main() void {
    const user = User{
        .power = 9001,
        .name = "Пётр",
    };

    std.debug.print("{s} обладает силой {d}\n", .{user.name, user.power});
}

pub const User = struct {
    power: u64,
    name: []const u8,
};
```

Сохраните этот исходный текст в файл с именем `ex-ch01-01.zig` и запустите его следующим образом:

```
zig run ex-ch01-01.zig 
```

Вы должны увидеть

```
Пётр обладает силой 9001
```

Этот пример достаточно простой, чтобы более-менее понять его, даже если Вы раньше
никогда не видели исходных текстов на языке Zig. Тем не менее, далее мы разберём его построчно.

## Импортирование библиотек

Редко когда бывает, что исходные тексты программы содержатся в одном-единственном файле
и при этом программа не использует никакие библиотеки. Наша первая программа также не
является исключением - она использует стандартную библиотеку Zig для того, чтобы напечатать
строчку, которую мы только что видели. Система импорта/экспорта в Zig достаточно проста
и базируется на 2-х вещах

* `@import` - это встроенная в компилятор функция
* `pub` - ключевое слово для экспортирования чего-то 

При импортировании модуля нужно указать его имя. Стандартная библиотека Zig доступна
по имени `std`. Чтобы импортировать какой-то конкретный файл, нужно использовать
путь относительно того файла, в котором делается импортирование. Например, мы могли
бы поместить описание структуры `User` в отдельный файл (скажем, `models/user.zig`)
и тогда бы в основном файле мы бы написали

```zig
const User = @import("models/user.zig").User;
```

При этом эта структура должна быть помечена как `pub`, в противном случае мы получим
ошибку компиляции, в которой будет сказано, что эта структура не является публичной.

Наш гипотетический `models/user.zig`, помимо структуры `User`, может экспортировать
и другие вещи. Например, мы могли бы также экспортировать константу:

```zig
// models/user.zig
pub const MAX_POWER = 100_000;

pub const User = struct {
    power: u64,
    name: []const u8,
};
```

И тогда бы могли в главном файле импортировать обе сущности:

```
const user = @import("models/user.zig");
const User = user.User;
const MAX_POWER = user.MAX_POWER;
```

Скорее всего, на данный момент у Вас больше вопросов, чем ответов.
Что такое `user` в приведенном отрывке? Хотя мы ещё не знакомы с ключевым
словом `var`, но тем не менее можно спросить, а что, если вместо `const`
использовать `var`? Или. возможно, у Вас возник вопрос по поводу использования
сторонних библиотек. Это всё хорошие вопросы, но чтобы ответить на них,
нам нужно глубже изучить Zig, а пока нам придётся обойтись тем, что мы уже 
знаем, а именно: 

* как импортировать стандартную библиотеку (`const std = @import("std");`)
* как импортировать свои собственные файлы (`const user = @import(models/user.zig)`)
* как экспортировать те или иные определения (`pub const ...`)

## Комментарии

Следующая строчка в примере это комментарий:
```
// Если тут убрать слово 'pub', то этот код не откомпилируется
```

В Zig нет многострочных комментариев в стиле C (`/* ... */`), но зато есть 3 различных
вида однострочных:

* `//` - обычные комментарии в стиле C++
* `//!` - комментарии "верхнего уровня", размещаются в начале файла
* `///` - документирующие комментарии, располагаются перед определениями

## Функции

После комментария в нашем примере идёт строчка

```zig
pub fn main() void {
```

Это начало главной функции программы. В каждом исполнимом файле должна существовать
функция, с которой начинается выполнение, это входная точка программы. Если переименовать
`main` во что-то другое, например, в `doIt` и попытаться запустить нашу
программу, то мы получим сообщение об ошибке, в котором говорится, что в нашем
файле нет функции `main`:

```
/opt/zig-0.11/lib/std/start.zig:559:45: error: root struct of file 'ex-ch01-01' has no member named 'main'
```

Если не принимать во внимание особую роль функции `main` как точки входа,
то в остальном это обычная функция, то есть она может принимать параметры
и возвращать какое-то значение. В данном случае наша `main` ничего
не принимает (что обозначено отсутствием чего бы то ни было внутри круглых
скобок) и ничего не возвращает, что обозначено ключевым словом `void`.

Следующий пример будет чуть-чуть более интересен:

```zig
const std = @import("std");

pub fn main() void {
    const sum = add(8999, 2);
    std.debug.print("8999 + 2 = {d}\n", .{sum});
}

fn add(a: i64, b: i64) i64 {
    return a + b;
}
```

Программисты, пишущие на языках C или C++, наверняка заметят, что Zig
не требует объявления/определения функции до её использования, функция
`add` вызывается раньше (по тексту), чем встречается её определение.

Далее отметим тип `i64`. Вот некоторые другие целочисленные/вещественные типы: 
`u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u47`, `i47`, `u64`, `i64`, `f32` and `f64`.
Наличие в списке `u47` и `i47` это вовсе не проверка того, что Вы ещё не спите -
Zig умеет работать с целыми числами произвольного размера (в битах). Возможно,
Вы не будете использовать такие типы (`u1`, `s9` и т.п.), однако, иногда
они удобны или даже необходимы. Тип, который Вы точно будете часто использовать,
это `usize` - это целочисленный тип размером с указатель (для данной платформы) и
это тип представляет длину/размер чего-либо.

Давайте (без всякой на то причины) изменим реализацию функции `add` вот таким
образом:

```zig
fn add(a: i64, b: i64) i64 {
    a += b;
    return a;
}
```

Мы получим ошибку в строчке, где `a += b`, "нельзя присваивать значение константе".
Это важное наблюдение, к которому мы ещё вернёмся позже: параметры функций являются
константами.

В Zig, ради лучшей читабельности, нет перегрузки функций, то есть нельзя сделать
несколько функций с одинаковыми именами, но с разными типами параметров
или с разным их количеством. На данный момент это всё, что нам нужно знать про функции.

## Структуры

Далее в нащем примере идёт создание экземпляра структуры `User`,
определение которой располагается после функции `main` и которое гласит:

```zig
pub const User = struct {
    power: u64,
    name: []const u8,
};
```
Поскольку эта структура у нас используется только в том же файле, где и 
определена, то слово `pub` тут необязательно. Оно было использовано для
того, чтобы ознакомиться с экспортом определений.

Поля структуры оканчиваются запятой (в отличие от С) и им можно присвоить
значение по умолчанию (также в отличие от С):

```zig
pub const User = struct {
    power: u64 = 0,
    name: []const u8,
};
```

Когда мы создаём экземпляр структуры, *все* её поля должны быть проинициализированы.
Например, если использовать наше первоначальное определение структуры `User`
(у которой поле `power` не имеет значения по умолчанию) и написать

```
const user = User{.name = "Пётр"};
```
то мы получим ошибку, в которой будет сообщено, что поле `power` отсутствует.
Если же использовать определение, в котором для поля `power` заданом значение по умолчанию,
то тогда такой код успешно откомпилируется.

Структуры могут иметь методы, они могут содержать определения (включая другие структуры),
а также могут быть вообще пустыми (и в таком случае они работают как пространства имён).

```zig
pub const User = struct {
    power: u64 = 0,
    name: []const u8,

    pub const SUPER_POWER = 9000;

    fn diagnose(user: User) void {
        if (user.power >= SUPER_POWER) {
            std.debug.print("Вот это силища, больше, чем {d}!!!", .{SUPER_POWER});
        }
    }
};
```

Методы это просто обычные функции, которые можно вызвать, используя точку:

```zig
// вызвать функцию diagnose для некоторого экземпляра User
user.diagnose();

// предыдущая строчка это "синтаксический сахар" для вот такой полной формы:
User.diagnose(user);
```

