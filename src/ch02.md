
# Обзор языка. Часть II

В этой главе мы рассмотрим то, что было опущено в предыдущей -
инструкции управления выполнением программы, а также типы данных,
о которых мы ещё не упоминали (объединения и ошибки).

## Управление потоком выполнения

Операторы управления потоком исполнения в Zig, безусловно, покажутся Вам знакомыми,
однако, имеется ряд моментов, касающихся их взаимодействия с некоторыми
другими аспектами языка, которые нам пока лишь предстоить изучить.
Мы начнём с краткого обзора и будем возвращаться по мере того,
как нам будут встречаться особенности в поведении инструкцмй управления. 

Далее Вы заметите, что для логических операторов "И" и "ИЛИ" в Zig
используются обозначения `and` и `or`, а не `&&` и `||`. Как и во многих
других языках, эти операторы влияют на ход исполнения программы,
поскольку при компиляции выражений, содержащих эти операторы, применяется
оптимизация, состоящая в том, что выражение справа от знака операции
может вообще не вычисляться - выражение справа от `and` не вычисляется,
если выражение слева есть `false`, выражение справа от `or` не вычисляется,
если выражение слева равно `true`. В Zig управление потоком осуществляется с помощью
ключевых слов, именно поэтому для логических операций используются
слова `and` и `or`, а не "комбинации закорючек".

Далее, оператор сравнения (`==`) не работает для срезов, например, для строк (`[]const u8`).
В большинстве случаев для сравнения Вы будете использовать `std.mem.eql(u8, str1, str2)`,
которая сначала сравнивает длины срезов, а потом побайтно их содержимое.

Операторы `if`, `else if`, `else` в Zig ничем особо не примечательны:

```zig
// std.mem.eql осуществляет побайтное сравнение
// для строки такое сравнение будет чувствительным к регистру
if (std.mem.eql(u8, method, "GET") or std.mem.eql(u8, method, "HEAD")) {
    // обрабатываем запрос GET
} else if (std.mem.eql(u8, method, "POST")) {
    // обрабатываем запрос POST
} else {
    // ...
}
```
Первый аргумент функции `std.mem.eql` является *типом*. Это первая обобщенная
функция, которую мы видим. Более подробно мы исследуем этот вопрос далее.

Приведённый пример сравнивает ASCII-строки и, по идее, здесь не нужно
учитывать регистр, поэтому лучшим вариантом будет `std.ascii.eqlIgnoreCase(str1, str2)`.

В Zig нет тернарного оператора (`const is_super = power > 9000? true : false`),
но можно использовать `if/else`, вот таким вот образом:

```zig
const is_super = if (power > 9000) true else false;
```

То есть управляющие конструкции являются выражениями, они могут возвращать значение
и, соответственно, могут быть использованы в правой части оператора присваивания.

Оператор `switch` в какой-то степени подобен каскаду `if/else if`, но 
имеет то преимущество, что должны быть указаны все возможные варианты.
Вот этот код не пройдёт компиляцию:

```zig
fn anniversaryName(years_married: u16) []const u8 {
    switch (years_married) {
        1 => return "бумажная",
        2 => return "хлопковая",
        3 => return "кожаная",
        4 => return "цветочная",
        5 => return "деревянная",
        6 => return "сахарная",
    }
}
```

Компилятор нам скажет, что `switch` должен обрабатывать все возможные значения для `years_married`.
Поскольку этот параметр имеет тип `u16`, то возможных значений у нас 65536 и писать
их все представляется крайне непрактичным, К счастью, у оператора `switch`
есть оборот `else`:

```zig
6 => return "сахарная",
else => return "столько вместе не живут",
```

Для обозначения возможных случаев можно использовать перечисления (через запятую),
диапазоны (с помощью *трёх* точек), а также использовать блоки для кода со сложной
в каком-то смысле логикой:

```zig
fn arrivalTimeDesc(minutes: u16, is_late: bool) []const u8 {
    switch (minutes) {
        0 => return "прибыл",
        1, 2 => return "почти прибыл",
        3...5 => return "прибудет в течении 5 минут",
        else => {
            if (!is_late) {
                return "извините, придётся немного подождать";
            }
            // что-то пошло вообще не так
            return "никогда не прибудет";
        },
    }
}
```

Хотя `switch` и бывает иногда полезным для перебора по числам,
его исчерпывающее поведение (в смысле "нужно перечислить все возможные варианты")
проявляет себя во всей красе, когда мы работаем с переменными перечислимого типа,
о котором мы вскоре поговорим.


## Перечислимый тип

## Объединения с пометками

## Необязательные значения (Optionals)

## Инициализатор undefined

## Ошибки и их обработка

## 




