
# Обзор языка. Часть II

В этой главе мы рассмотрим то, что было опущено в предыдущей -
инструкции управления выполнением программы, а также типы данных,
о которых мы ещё не упоминали (объединения и ошибки).

## Управление потоком выполнения

Операторы управления потоком исполнения в Zig, безусловно, покажутся Вам знакомыми,
однако, имеется ряд моментов, касающихся их взаимодействия с некоторыми
другими аспектами языка, которые нам пока лишь предстоить изучить.
Мы начнём с краткого обзора и будем возвращаться по мере того,
как нам будут встречаться особенности в поведении инструкций управления. 

Далее Вы заметите, что для логических операторов "И" и "ИЛИ" в Zig
используются обозначения `and` и `or`, а не `&&` и `||`. Как и во многих
других языках, эти операторы влияют на ход исполнения программы,
поскольку при компиляции выражений, содержащих эти операторы, применяется
оптимизация, состоящая в том, что выражение справа от знака операции
может вообще не вычисляться - выражение справа от `and` не вычисляется,
если выражение слева есть `false`, выражение справа от `or` не вычисляется,
если выражение слева равно `true`. В Zig управление потоком осуществляется с помощью
ключевых слов, именно поэтому для логических операций используются
слова `and` и `or`, а не "комбинации закорючек".

Далее, оператор сравнения (`==`) не работает для срезов, например, для строк (`[]const u8`).
В большинстве случаев для сравнения Вы будете использовать `std.mem.eql(u8, str1, str2)`,
которая сначала сравнивает длины срезов, а потом побайтно их содержимое.

Операторы `if`, `else if`, `else` в Zig ничем особо не примечательны:

```zig
// std.mem.eql осуществляет побайтное сравнение
// для строки такое сравнение будет чувствительным к регистру
if (std.mem.eql(u8, method, "GET") or std.mem.eql(u8, method, "HEAD")) {
    // обрабатываем запрос GET
} else if (std.mem.eql(u8, method, "POST")) {
    // обрабатываем запрос POST
} else {
    // ...
}
```

Первый аргумент функции `std.mem.eql` является *типом*. Это первая обобщенная
функция, которую мы видим. Более подробно мы исследуем этот вопрос далее.

Приведённый пример сравнивает ASCII-строки и, по идее, здесь не нужно
учитывать регистр, поэтому лучшим вариантом будет `std.ascii.eqlIgnoreCase(str1, str2)`.

В Zig нет тернарного оператора (`const is_super = power > 9000? true : false`),
но можно использовать `if/else`, вот таким вот образом:

```zig
const is_super = if (power > 9000) true else false;
```

То есть управляющие конструкции являются выражениями, они могут возвращать значение
и, соответственно, могут быть использованы в правой части оператора присваивания.

Оператор `switch` в какой-то степени подобен каскаду `if/else if`, но 
имеет то преимущество, что должны быть указаны все возможные варианты.
Вот этот код не пройдёт компиляцию:

```zig
fn anniversaryName(years_married: u16) []const u8 {
    switch (years_married) {
        1 => return "бумажная",
        2 => return "хлопковая",
        3 => return "кожаная",
        4 => return "цветочная",
        5 => return "деревянная",
        6 => return "сахарная",
    }
}
```

Компилятор нам скажет, что `switch` должен обрабатывать все возможные значения для `years_married`.
Поскольку этот параметр имеет тип `u16`, то возможных значений у нас 65536 и писать
их все представляется крайне непрактичным, К счастью, у оператора `switch`
есть оборот `else`:

```zig
6 => return "сахарная",
else => return "столько вместе не живут",
```

Для обозначения возможных случаев можно использовать перечисления (через запятую),
диапазоны (с помощью *трёх* точек), а также использовать блоки для кода со сложной
в каком-то смысле логикой:

```zig
fn arrivalTimeDesc(minutes: u16, is_late: bool) []const u8 {
    switch (minutes) {
        0 => return "прибыл",
        1, 2 => return "почти прибыл",
        3...5 => return "прибудет в течении 5 минут",
        else => {
            if (!is_late) {
                return "извините, придётся немного подождать";
            }
            // что-то пошло вообще не так
            return "никогда не прибудет";
        },
    }
}
```

Хотя `switch` и бывает иногда полезным для перебора по числам,
его исчерпывающее поведение (в смысле "нужно перечислить все возможные варианты")
проявляет себя во всей красе тогда, когда мы работаем с переменными перечислимого типа,
о котором мы вскоре поговорим.

Для итерирования по массивам, срезам и диапазонам в Zig используется цикл `loop`.
Например, для проверки того, содержится ли какое-либо значение в массиве,
можно написать такой код:

```zig
fn contains(haystack: []const u32, needle: u32) bool {
    for (haystack) |value| {
        if (needle == value) {
            return true;
        }
    }
    return false;
}
```

Циклы `for` могут проходить по нескольким последовательностям одновременно,
разумеется, при условии, что их длины равны, Выше мы использовали функцию
сравнения, `std.mem.eql`. Вот так эта функция (ну, примерно) выглядит:

```zig
pub fn eql(comptime T: type, a: []const T, b: []const T) bool {
    // если они разной длины, они никак не могут быть равными
    if (a.len != b.len) return false;

    for (a, b) |a_elem, b_elem| {
        if (a_elem != b_elem) return false;
    }

    return true;
}
```

Начальный `if` это не просто некая оптимизация по производительности,
эту проверку делать необходимо - если мы передадим аргументы разной длины,
а этой проверки не будет, то наша программа "упадёт" (runtime panic)

Циклы `for` также можно использовать с диапазонами:

```zig
for (0..10) |i| {
    std.debug.print("{d}\n", .{i});
}
```

Тут мы вернёмся к оператору `switch`. Там для обозначения диапазонов 
мы использовали 3 точки, а тут две. Дело в том, что интервал,
обозначенный тремя точками, является закрытым с обеих концов,
а интервал вида `0..n` открыт с правого конца, то есть само `n` туда не входит.

Особенно замечательно это смотрится в комбинации со срезами (или с несколькими!):

```zig
fn indexOf(haystack: []const u32, needle: u32) ?usize {
    for (haystack, 0..) |value, i| {
        if (needle == value) {
            return i;
        }
    }
    return null;
}
```

Обратите внимание на тип возвращаемого значения (`?usize`), 
а именно, на знак вопроса. Таким образом в Zig обозначается
необязательность значения (подобно `nullable` полям в реляционных базах данных).
Так же и тут - если ничего не найдено, то возвращаем `null`.
Подробнее про такие типы см. ниже, в соответствующем разделе этой главы.

Также обратите внимание на то, что правый конец интервала не написан,
он будет автоматически определён исходя из фактической длины аргументв `haystack`.
Впрочем, ничто не мешает написать явно, то есть `0..hastack.len`.

Циклы `for` не поддерживают более общую идиому вида `(init; compare; next)`.
Для этого следует использовать циклы `while`. Поскольку цикл `while`
в некотором смысле проще, чем цикл `for`, при использовании его формы
в виде `while (condition) { }` у нас больше контроля за процессом итерирования.
Например, при подсчёте количества экранирующих символов в строке
нам нужно особенным образом учесть случай `\\` - именно, нужно увеличить
индекс на 2, чтобы избежать двойного учёта:

```zig
var i: usize = 0;
var escape_count: usize = 0;
while (i < src.len) {
    if (src[i] == '\\') {
        i += 2;
        escape_count += 1;
    } else {
        i += 1;
    }
}
```

Циклы `while` могут иметь оборот `else`, который исполняется тогда,
когда условие оказывается сразу ложным. Также у цикла `while` может
присутствовать дополнительная инструкция, которая будет исполняться
*в конце* каждой итерации, она отделяется от условия двоеточием:

```zig
var i: usize = 0;
var escape_count: usize = 0;

while (i < src.len) : (i += 1) {
    if (src[i] == '\\') {
        // +1 тут, и  +1 выше, итого +2
        i += 1;
        escape_count += 1;
    }
}
```

В циклах `while` и `for` можно использовать `break`, для досрочного выхода из цикла
и `continue`, для досрочного перехода к следующей итерации.

Если циклы вложены, то они могут быть помечены, а метки могут быть
использованы вместе с `break` и `continue` для указания того,
какой конкретно цикл имеется ввиду. Надуманный пример:

```zig
outer: for (1..10) |i| {
    for (i..10) |j| {
        if (i * j > (i+i + j+j)) continue :outer;
        std.debug.print("{d} + {d} >= {d} * {d}\n", .{i+i, j+j, i, j});
    }
}
```

У `break`, помимо использования в циклах, есть ещё одно интересное применение,
возвращение значения из блока кода:

```zig
const personality_analysis = blk: {
    if (tea_vote > coffee_vote) break :blk "sane";
    if (tea_vote == coffee_vote) break :blk "whatever";
    if (tea_vote < coffee_vote) break :blk "dangerous";
};
```

Блоки подобного рода нужно оканчивать точкой с запятой.

Позже, когда мы будем изучать объединения с пометками,
объединения-ошибки и типы с необязательным значением,
мы узнаем, какие ещё возможности предоставляют управляющие структуры.

## Перечисления (enums)

Перечисление это набор целочисленных констант, каждой из которых дано имя.
Определяются они примерно как структуры, то есть:

```zig
// непубличное перечисление, снаружи недоступно
const Status = enum {
    ok,
    bad,
    unknown,
};
```

И. как и структуры, перечисления могут содержать другие определения,
включая функции, которые в качестве аргумента могут использовать
перечисление, в которое они входят (а могут и не использовать):

```zig
const Stage = enum {
    validate,
    awaiting_confirmation,
    confirmed,
    completed,
    err,

    fn isComplete(self: Stage) bool {
        return self == .confirmed or self == .err;
    }
};
```

Чтобы получить строковое представление для элементов перечисления,
можно использовать встроенную функцию `@tagName`.

Вспомним, что при использовании записи вида `.{...}` типы структур
выводятся исходя из типа переменной, которой присваивается анонимная
структурв или из типа возвращаемого значения функции. В примере
выше мы видим, что при сравнениях тип перечисления тоже выводится,
исходя из типа параметра (`Stage`). Можно написать явно, то есть
`return self == Stage.confirmed or self == Stage.err;`, но, как правило,
тип опускается и пишется только точка и значение.

То, что в операторе `switch` нужно указывать все возможные варианты
(ну, если нет оборота `else`), просто замечательно сочетается с
перечислениями -  если мы что-то забыли, компилятор нам подскажет.
И будьте осторожны, если у Вас в `switch` есть оборот `else` - 
если Вы вдруг добавите новые элементы в перечисление, то они все
попадут в этот `else` и, скорей всего, программа не будет работать так,
как Вы задумывали.

## Объединения (union) и маркированные объединения(union(enum))

Объединение задаёт набор типов, которые может иметь переменная.
Например, экземпляры следующего объединения могут быть или
целыми числами, или числами с плавабщей точкой, или быть "не-числом" (Nan):

```zig
const std = @import("std");

pub fn main() void {
    const n = Number{.int = 32};
    std.debug.print("{d}\n", .{n.int});
}

const Number = union {
    int: i64,
    float: f64,
    nan: void,
};
```

В каждый момент времени переменная-объединение может иметь
только одно установленное поле. Если мы попытаемся обратиться
к неустановленному полю, то это будет ошибкой. Поскольку в примере
мы выставили поле `int`, то, если бы мы попытались использовать поле `float`,
мы получили бы ошибку. Одно из наших полей (`nan`) имеет тип `void`.
Что это значит? Как такому полю присвоить значение? Используйте `{}`

```zig
const n = Number{.nan = {}};
```

Большая проблема с объединениями - это определение того, какое именно
поле выставлено (активировано) в данный момент. И тут на выручку
к нам приходят маркированные объединения (tagged unions). Маркированное
объединение это как бы гибрид перечисления и обычного объединения.
Рассмотрим такой вот пример:

```zig

const std = @import("std");

pub fn main() void {
    const ts = Timestamp{.unix = 1699689923};
    std.debug.print("{d}\n", .{ts.seconds()});
}

const TimestampType = enum {
    unix,
    datetime,
};

const Timestamp = union(TimestampType) {
    unix: i64,
    datetime: DateTime,

    const DateTime = struct {
        year: u16,
        month: u8,
        day: u8,
        hour: u8,
        minute: u8,
        second: u8,
    };

    fn seconds(self: Timestamp) u16 {
        switch (self) {
            .datetime => |dt| return dt.second,
            .unix => |ts| {
                const seconds_since_midnight: i64 = @rem(ts, 86400);
                return @intCast(@rem(seconds_since_midnight, 60));
            },
        }
    }
};
```

Обратите внимание, что в операторе `switch` для каждого из 
2-х вариантов  значение "захватывается" в некую как бы переменную,
это делается при помощи `|val|`. В нашем примере `dt` это `Timestamp.DateTime`,
а `ts` это `i32`. В этом примере мы также впервые видим вложенное
определение - структура `DateTime` определяется внутри объединения `TimeStamp`.
Но ничто не мешает определить её и вне этого объединения.
Также мы тут видим 2 новых встроенных функции: `@rem` для вычисления остатка
от деления и `@intCast` для преобразования типа от `i64` к `u16`
(это следует из типа возвращаемого значения функции `seconds`).

Как мы видим из приведённого примера, маркированные объединения
можно использовать как своего рода интерфейсы при условии,
что все возможные реализации известны заранее и поэтому могут
быть включены в наше маркированное объединение.

Ну, и наконец, перечисление для маркированного объединения может
быть выведено автоматически. Можно смело писать

```zig
const Timestamp = union(enum) {
    unix: i32,
    datetime: DateTime,
```

и тогда компилятор Zig создаст неявное перечисление,
основываясь на именах полей. 


## Необязательные значения (Optionals)

## Инициализатор undefined

## Ошибки и их обработка

## 
