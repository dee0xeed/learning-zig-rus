
# Обзор языка. Часть II

В этой главе мы рассмотрим то, что было опущено в предыдущей -
инструкции управления выполнением программы, а также типы данных,
о которых мы ещё не упоминали (объединения и ошибки).

## Управление потоком выполнения

Операторы управления потоком исполнения в Zig, безусловно, покажутся Вам знакомыми,
однако, имеется ряд моментов, касающихся их взаимодействия с некоторыми
другими аспектами языка, которые нам пока лишь предстоить изучить.
Мы начнём с краткого обзора и будем возвращаться по мере того,
как нам будут встречаться особенности в поведении инструкцмй управления. 

Далее Вы заметите, что для логических операторов "И" и "ИЛИ" в Zig
используются обозначения `and` и `or`, а не `&&` и `||`. Как и во многих
других языках, эти операторы влияют на ход исполнения программы,
поскольку при компиляции выражений, содержащих эти операторы, применяется
оптимизация, состоящая в том, что выражение справа от знака операции
может вообще не вычисляться - выражение справа от `and` не вычисляется,
если выражение слева есть `false`, выражение справа от `or` не вычисляется,
если выражение слева равно `true`. В Zig управление потоком осуществляется с помощью
ключевых слов, именно поэтому для логических операций используются
слова `and` и `or`, а не "комбинации закорючек".

Далее, оператор сравнения (`==`) не работает для срезов, например, для строк (`[]const u8`).
В большинстве случаев для сравнения Вы будете использовать `std.mem.eql(u8, str1, str2)`,
которая сначала сравнивает длины срезов, а потом побайтно их содержимое.

Операторы `if`, `else if`, `else` в Zig ничем особо не примечательны:

```zig
// std.mem.eql осуществляет побайтное сравнение
// для строки такое сравнение будет чувствительным к регистру
if (std.mem.eql(u8, method, "GET") or std.mem.eql(u8, method, "HEAD")) {
    // обрабатываем запрос GET
} else if (std.mem.eql(u8, method, "POST")) {
    // обрабатываем запрос POST
} else {
    // ...
}
```
Первый аргумент функции `std.mem.eql` является *типом*. Это первая обобщенная
функция, которую мы видим. Более подробно мы исследуем этот вопрос далее.

Приведённый пример сравнивает ASCII-строки и, по идее, здесь не нужно
учитывать регистр, поэтому лучшим вариантом будет `std.ascii.eqlIgnoreCase(str1, str2)`.

В Zig нет тернарного оператора (`const is_super = power > 9000? true : false`),
но можно использовать `if/else`, вот таким вот образом:

```zig
const is_super = if (power > 9000) true else false;
```

То есть управляющие конструкции являются выражениями, они могут возвращать значение
и, соответственно, могут быть использованы в правой части оператора присваивания.

Оператор `switch` в какой-то степени подобен каскаду `if/else if`, но 
имеет то преимущество, что должны быть указаны все возможные варианты.
Вот этот код не пройдёт компиляцию:

```zig
fn anniversaryName(years_married: u16) []const u8 {
    switch (years_married) {
        1 => return "бумажная",
        2 => return "хлопковая",
        3 => return "кожаная",
        4 => return "цветочная",
        5 => return "деревянная",
        6 => return "сахарная",
    }
}
```

Компилятор нам скажет, что `switch` должен обрабатывать все возможные значения для `years_married`.
Поскольку этот параметр имеет тип `u16`, то возможных значений у нас 65536 и писать
их все представляется крайне непрактичным, К счастью, у оператора `switch`
есть оборот `else`:

```zig
6 => return "сахарная",
else => return "столько вместе не живут",
```

Для обозначения возможных случаев можно использовать перечисления (через запятую),
диапазоны (с помощью *трёх* точек), а также использовать блоки для кода со сложной
в каком-то смысле логикой:

```zig
fn arrivalTimeDesc(minutes: u16, is_late: bool) []const u8 {
    switch (minutes) {
        0 => return "прибыл",
        1, 2 => return "почти прибыл",
        3...5 => return "прибудет в течении 5 минут",
        else => {
            if (!is_late) {
                return "извините, придётся немного подождать";
            }
            // что-то пошло вообще не так
            return "никогда не прибудет";
        },
    }
}
```

Хотя `switch` и бывает иногда полезным для перебора по числам,
его исчерпывающее поведение (в смысле "нужно перечислить все возможные варианты")
проявляет себя во всей красе тогда, когда мы работаем с переменными перечислимого типа,
о котором мы вскоре поговорим.

Для итерирования по массивам, срезам и диапазонам в Zig используется цикл `loop`.
Например, для проверки того, содержится ли какое-либо значение в массиве,
можно написать такой код:

```zig
fn contains(haystack: []const u32, needle: u32) bool {
    for (haystack) |value| {
        if (needle == value) {
            return true;
        }
    }
    return false;
}
```

Циклы `for` могут проходить по нескольким последовательностям одновременно,
разумеется, при условии, что их длины равны, Выше мы использовали функцию
сравнения, `std.mem.eql`. Вот так эта функция (ну, примерно) выглядит:

```zig
pub fn eql(comptime T: type, a: []const T, b: []const T) bool {
    // если они разной длины, они никак не могут быть равными
    if (a.len != b.len) return false;

    for (a, b) |a_elem, b_elem| {
        if (a_elem != b_elem) return false;
    }

    return true;
}
```

Начальный `if` это не просто некая оптимизация по производительности,
эту проверку делать необходимо - если мы передадим аргументы разной длины,
а этой проверки не будет, то наша программа "упадёт" (runtime panic)

Циклы `for` также можно использовать с диапазонами:

```zig
for (0..10) |i| {
    std.debug.print("{d}\n", .{i});
}
```

Тут мы вернёмся к оператору `switch`. Там для обозначения диапазонов 
мы использовали 3 точки, а тут две. Дело в том, что интервал,
обозначенный тремя точками, является закрытым с обеих концов,
а интервал вида `0..n` открыт с правого конца, то есть само `n` туда не входит.

Особенно замечательно это смотрится в комбинации со срезами (или с несколькими!):

```zig
fn indexOf(haystack: []const u32, needle: u32) ?usize {
    for (haystack, 0..) |value, i| {
        if (needle == value) {
            return i;
        }
    }
    return null;
}
```

Обратите внимание на тип возвращаемого значения (`?usize`), 
а именно, на знак вопроса. Таким образом в Zig обозначается
необязательность значения (подобно `nullable` полям в реляционных базах данных).
Так же и тут - если ничего не найдено, то возвращаем `null`.
Подробнее про такие типы см. ниже, в соответствующем разделе этой главы.

Также обратите внимание на то, что правый конец интервала не написан,
он будет автоматически определён исходя из фактической длины аргументв `haystack`.
Впрочем, ничто не мешает написать явно, то есть `0..hastack.len`.

Циклы `for` не поддерживают более общую идиому вида `(init; compare; next)`.
Для этого следует использовать циклы `while`. Поскольку цикл `while`
в некотором смысле проще, чем цикл `for`, при использовании его формы
в виде `while (condition) { }` у нас больше контроля за процессом итерирования.
Например, при подсчёте количества экранирующих символов в строке
нам нужно особенным образом учесть случай `\\` - именно, нужно увеличить
индекс на 2, чтобы избежать двойного учёта:

```zig
var i: usize = 0;
var escape_count: usize = 0;
while (i < src.len) {
    if (src[i] == '\\') {
        i += 2;
        escape_count += 1;
    } else {
        i += 1;
    }
}
```

Циклы `while` могут иметь оборот `else`, который исполняется тогда,
когда условие оказывается сразу ложным. Также у цикла `while` может
присутствовать дополнительная инструкция, которая будет исполняться
*в конце* каждой итерации, она отделяется от условия двоеточием:

```zig
var i: usize = 0;
var escape_count: usize = 0;

while (i < src.len) : (i += 1) {
    if (src[i] == '\\') {
        // +1 тут, и  +1 выше, итого +2
        i += 1;
        escape_count += 1;
    }
}
```

В циклах `while` и `for` можно использовать `break`, для досрочного выхода из цикла
и `continue`, для досрочного перехода к следующей итерации.

Если циклы вложены, то оин могут быть помечены, а метки могут быть использованы вместе `break`
и `continue` для указания того, какой конкретно цикл имеется ввиду. Надуманный примерЖ

```zig
outer: for (1..10) |i| {
    for (i..10) |j| {
        if (i * j > (i+i + j+j)) continue :outer;
        std.debug.print("{d} + {d} >= {d} * {d}\n", .{i+i, j+j, i, j});
    }
}
```

У `break`, помимо использования в циклах, есть ещё одно интересное применение,
возвращение значения из блока кода:

```zig
const personality_analysis = blk: {
    if (tea_vote > coffee_vote) break :blk "sane";
    if (tea_vote == coffee_vote) break :blk "whatever";
    if (tea_vote < coffee_vote) break :blk "dangerous";
};
```

Блоки подобного рода нужно оканчивать точкой с запятой.

Позже, когда мы будем изучать объединения с пометками,
объединения-ошибки и типы с необязательным значением,
мы узнаем, какие ещё возможности предоставляют управляющие структуры.

## Перечислимый тип

## Объединения с пометками

## Необязательные значения (Optionals)

## Инициализатор undefined

## Ошибки и их обработка

## 




