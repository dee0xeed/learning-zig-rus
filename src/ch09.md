
# Программируем на языке Zig

Теперь, когда большая часть языка рассмотрена, мы подытожим наши знания,
возвращаясь по мере необходимости к уже знакомым темам, а также
познакомимся с некоторыми практическими аспектами использования Zig.

## Снова висячие указатели

Начнём с рассмотрения ещё нескольких примеров висячих указателей.
Может показаться странным, что мы опять к этому возвращаемся,
однако, если ранее Вы использовали только языки со сборкой мусора,
то, скорее всего, висячие указатели будут вызывать наибольшие трудности
из тех, с которыми Вы будете сталкиваться.

Сможете догадаться, что напечатает следующий пример?

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    var lookup = std.StringHashMap(User).init(allocator);
    defer lookup.deinit();

    const goku = User{.power = 9001};

    try lookup.put("Goku", goku);

    // returns an optional, .? would panic if "Goku"
    // wasn't in our hashmap
    const entry = lookup.getPtr("Goku").?;

    std.debug.print("Goku's power is: {d}\n", .{entry.power});

    // returns true/false depending on if the item was removed
    _ = lookup.remove("Goku");

    std.debug.print("Goku's power is: {d}\n", .{entry.power});
}

const User = struct {
    power: i32,
};
```

Запустим:

```
$ /opt/zig-0.11/zig run src/ex-ch09-01.zig
Goku's power is: 9001
Goku's power is: -1431655766
```

В этом примере мы знакомимся с обобщённой хэш-таблицей
(`std.StringHashMap`), которая является специализилванной версией
`std.AutoHashMap` с типом ключа `[]const u8`. Даже если не уверены на все
сто относительно  того, что конкретно происходит при выводе, наверняка Вы
поняли, что это однозначно связано с тем, что второй вызов `print`
делается *после* того, как мы уже удалили элемент из таблицы. Если убрать
вызов `remove`, всё будет нормально.

Чтобы полностью понимать этот пример, нужно чётко представлять себе,
*где* находятся данные или, иными словами, кто ими *владеет*. Как мы
знаем, аргументы в функцию передаются по значению, то есть мы передаём
копию (возможно, поверхностную) значения переменной. Экземпляр `User` в
таблице `lookup` и `user` находятся в разных местах памяти, то есть в
этом коде у нас **два** пользователя, каждый со своим "владельцем".
`goku` находится во владении у функции `main`, а его копией владеет сама
таблица `lookup`.

Метод `getPtr` возвращает указатель на экземпляр в таблице (`*User` в нашем примере).
Собственно, в этом и "проблема", после вызова `remove` указатель
`entry` перестаёт показывать в правильное место. В примере у нас
`getPtr` и `remove` расположены в тексте близко друг к другу,
поэтому практически очевидно, в чём тут ошибка. Но совсем несложно
представить себе код, вызывающий `remove` без знания того,
что ссылка на элемент есть где-то ещё.

Помимо ошибочного вызова `remove` мы можем починить наш пример
и другими способами. Первый способ это использовать метод `get`
вместо `getPtr`. Этот метод возвращает копию `User`, а не указатель
на экземпляр, который находится в самой таблице. И тогда у нас 
будет **три** экземпляра `User`:

* исходный `goku`, созданный в `main`
* его копия в `lookup`, которая и владеет этой копией
* и копия копии, `entry`, ею владеет также `main`

Поскольку теперь `entry` это независимая копия,
удаление из таблицы ничего с ней не сделает.

Другой возможностью является изменить тип у таблицы с `StringHashMap(User)`
на `StringHashMap(*const User)`. Вот такой код будет работать правильно:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    // User -> *const User
    var lookup = std.StringHashMap(*const User).init(allocator);
    defer lookup.deinit();

    const goku = User{.power = 9001};

    // goku -> &goku
    try lookup.put("Goku", &goku);

    // getPtr -> get
    const entry = lookup.get("Goku").?;

    std.debug.print("Goku's power is: {d}\n", .{entry.power});
    _ = lookup.remove("Goku");
    std.debug.print("Goku's power is: {d}\n", .{entry.power});
}

const User = struct {
    power: i32,
};
```

В этом коде имеется несколько тонкостей. Прежде всего, теперь у нас
только один экземпляр пользователя. В таблице и в переменной `entry` у
нас теперь ссылки на этот экземпляр. Вызов `reomve`, как и прежде, всё
так же удаляет элемент из таблицы, но там у нас всего лишь указатель,
адрес переменной `user`, а не его полная копия. Если бы в последнем
варианте использовали бы `getPtr` (а не `get`), после `remove` указатель
`entry` (который тогда бы был `**User`), тоже стал бы "сломанным". Оба
наши решения требуют использования `get` (а не `getPtr`), просто во
втором его варианте мы делаем копию адреса, а не всей структуры `User`.
Для больших объектов это может иметь серьёзное значение в плане влияния
на производительность.

Когда у нас всё происходит внутри одной функции и при этом наша структура
`User` невелика по размеру, всё это выглядит не иначе, как искусственно
созданная проблема. Поэтому нам нужен пример, который показал бы, что
вопросы владения являются первоочередной заботой.

## Владение

Про хэш-таблицы знают все и всё ими пользуются, они имеют массу
применений, со многими из которых Вы, вероятно, имели дело в своей
практике. Хотя они и могут использоваться как короткоживущие сущности,
но, как правило, они всё таки живут длительное время и поэтому требуют
столь же долгоживущих значений, которые Вы помещаете в таблицы.

В следующем примере хэш-таблица наполняется именами, которые пользователь
вводит с клавиатуры в терминале. Пустое имя завершает цикл ввода.
После этого программа проверяет, было ли среди введённых имен имя "Leto".

```zig
const std = @import("std");
const builtin = @import("builtin");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    var lookup = std.StringHashMap(User).init(allocator);
    defer lookup.deinit();

    // stdin is an std.io.Reader
    // the opposite of an std.io.Writer, which we already saw
    const stdin = std.io.getStdIn().reader();

    // stdout is an std.io.Writer
    const stdout = std.io.getStdOut().writer();

    var i: i32 = 0;
    while (true) : (i += 1) {
        var buf: [30]u8 = undefined;
        try stdout.print("Please enter a name: ", .{});
        if (try stdin.readUntilDelimiterOrEof(&buf, '\n')) |line| {
            var name = line;
            if (builtin.os.tag == .windows) {
                // In Windows lines are terminated by \r\n.
                // We need to strip out the \r
                name = std.mem.trimRight(u8, name, "\r");
            }
            if (name.len == 0) {
                break;
            }
            try lookup.put(name, .{.power = i});
        }
    }

    const has_leto = lookup.contains("Leto");
    std.debug.print("{any}\n", .{has_leto});
}

const User = struct {
    power: i32,
};
```

Программа учитывает регистр, но как бы аккуратно Вы не вводили "Leto",
метод `contains` будет всегда возвращать `false`. Давайте попробуем
отладить нашу программу, добавив для начала печать всех ключей
и значений после цикла ввода:

```zig
// Place this code after the while loop

var it = lookup.iterator();
while (it.next()) |kv| {
    std.debug.print("{s} == {any}\n", .{kv.key_ptr.*, kv.value_ptr.*});
}
```

Такой шаблон для работы с итераторами типичен в Zig, и опирается он на
тесное взаимодействие между циклом `while` и необязательными значениями.
Итератор `it` возвращает указатели на ключ и на значение, поэтому мы
используем здесь разыменование (`.*`) для того, чтобы получить значение,
имея его адрес. Что ж, запускаем:

```
$ /opt/zig-0.11/zig run src/ex-ch09-03-debug.zig 
Please enter a name: Paul
Please enter a name: Teg
Please enter a name: Leto
Please enter a name: 

�� == ex-ch09-03-debug.User{ .power = 1 }

��� == ex-ch09-03-debug.User{ .power = 0 }

��� == ex-ch09-03-debug.User{ .power = 2 }
false
```

Значения вроде бы выглядят нормально, а вот с ключами у нас тут явно
что-то не то. Выше было сказано, что значения должны жить не меньше, чем
сама хэш-таблица. **Но и ключи таблицы тоже должны удовлетворять этому правилу!**.
Буфер `buf` у нас определён внутри цикла `while`. Когда мы вызываем `put`,
мы передаём ключ (имя пользователя), который живёт меньше, чем таблица.
Если мы поместим объявление буфера перед циклом, это решит вопрос
с его временем жизни, но буфер-то всё равно будет переиспользоваться
на каждой итерации цикла и поэтому программа всё равно не будет работать
как надо, поскольку мы всё время изменяем значение ключа.

Для нашего примера есть только одно решение: хэш-таблица должна владеть
не только значениями, но и ключами. Для этого Нужно сделать следующие
изменения:

```zig
// replace the existing lookup.put with these two lines
const owned_name = try allocator.dupe(u8, name);

// name -> owned_name
try lookup.put(owned_name, .{.power = i});
```

Метод `dupe` аллокатора, который ранее нам ещё не встречался, делает
дубликат, выделяя под него память. Теперь наш код будет работать
правильно, потому что ключи теперь размещены в куче и живут в любом
случае не меньше, чем хэш-таблица. Но есть одно но: теперь у нас
появились утечки памяти.

Возможно, Вы подумали, что когда мы вызываем `lookup.deinit`, память под
ключи и значения будет освобождена сама собой. Увы, `StringHashMap` не
может так сделать. Во-первых,  ключи могут быть строковыми литералами,
тогда строки хранятся в сегменте данных, а не в куче и их в принципе
невозможно убрать. Во-вторых, память под строки-ключи может быть выделена 
другим аллокатором. И наконец, могут быть вполне законные сценарии, когда
ключи не должны быть во владении у хэш-таблицы.

Поэтому единственное, что мы тут можем сделать, это освободить память под
ключи самостоятельно. Здесь, видимо, стоило бы подумать о создании своего
типа `UserLookup` и поместить логику с очисткой в деструктор `deinit`, но
мы пока так, небрежно:

```zig
// replace the existing:
//   defer lookup.deinit();
// with:
defer {
    var it = lookup.keyIterator();
    while (it.next()) |key| {
        allocator.free(key.*);
    }
    lookup.deinit();
}
```

Здесь мы впервые использовали `defer` с блоком, внутри которого мы
сначала чистим память, занимаемую ключами и затем, как и раньше, вызываем
деструктор таблицы. Обратите также внимание, что тут используется
`keyIterator`, чтобы пройтись только по ключам, значения нам тут не
нужны. Значение итератора `it` это указатель на ключ в таблице, то есть
это `*[]const u8`. Поэтому чтобы освободить память, здесь опять нужно
использовать разыменование (`key.*`).

Всё, достаточно с нас висячих указателей и управления памятью! То, что мы
обсуждали в этом разделе по-прежнему может казаться не совсем ясным или
слишком абстрактным. Но, тем не менее, если Вы планируете писать что-то
нетривиальное, можно совершенно определённо сказать, что управление
памятью это то, чем Вы будете должны овладеть в совершенстве. В этой
связи будет весьма полезно проделывать всяческие упражнения с кодом из
этого раздела. Например, сделайте тип `UserLookup`, который содержал бы в
себе весь код, связанный с динамической памятью. Попробуйте держать в
таблице указатели (`*User`), то есть выделяйте память под значения
таблицы тоже в куче и освобождайте её так, как мы это проделали с
ключами. Пишите тесты с использованием `std.testing.allocator`, чтобы
убедиться в отсутствии утечек памяти.

## Динамический массив `ArrayList`

```zig
const std = @import("std");
const builtin = @import("builtin");
const Allocator = std.mem.Allocator;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    var arr = std.ArrayList(User).init(allocator);
    defer {
        for (arr.items) |user| {
            user.deinit(allocator);
        }
        arr.deinit();
    }

    // stdin is an std.io.Reader
    // the opposite of an std.io.Writer, which we already saw
    const stdin = std.io.getStdIn().reader();

    // stdout is an std.io.Writer
    const stdout = std.io.getStdOut().writer();

    var i: i32 = 0;
    while (true) : (i += 1) {
        var buf: [30]u8 = undefined;
        try stdout.print("Please enter a name: ", .{});
        if (try stdin.readUntilDelimiterOrEof(&buf, '\n')) |line| {
            var name = line;
            if (builtin.os.tag == .windows) {
                // In Windows lines are terminated by \r\n.
                // We need to strip out the \r
                name = std.mem.trimRight(u8, name, "\r");
            }
            if (name.len == 0) {
                break;
            }
            const owned_name = try allocator.dupe(u8, name);
            try arr.append(.{.name = owned_name, .power = i});
        }
    }

    var has_leto = false;
    for (arr.items) |user| {
        if (std.mem.eql(u8, "Leto", user.name)) {
            has_leto = true;
            break;
        }
    }

    std.debug.print("{any}\n", .{has_leto});
}

const User = struct {
    name: []const u8,
    power: i32,

    fn deinit(self: User, allocator: Allocator) void {
        allocator.free(self.name);
    }
};
```

## `anytype`

## `@typeOf`

## Система сборки

## Сторонние зависимости
