
# Указатели

В Zig нет сборки мусора. Бремя управления памятью лежит
на разработчике. Это большая ответственность, поскольку
это имеет прямое влияние на производительность, стабильность
и безопасность ваших программ.

Мы начнём изучать указатели, это важная тема как сама по себе,
но также и для того, чтобы начать приучать себя смотреть
на программы с точки зрения использования памяти компьютера.
Если Вы свободно обращаетесь с указателями, динамическим
выделением/освобождением памяти, понимаете, что такое
"висячий" указатель (dangling pointer), тогда Вы можете
пропустить пару глав и перейти к главе 6, там есть
некоторые особенности, специфичные для Zig.

В следующем примере создаётся пользователь с идентификатором 1
и "силой" 100, а затем вызывается функция, которая увеличивает
силу пользователя на единицу. Можете угадать, что выведет эта программа?

```zig
const std = @import("std");

pub fn main() void {
    var user = User{
        .id = 1,
        .power = 100,
    };

    // this line has been added
    levelUp(user);
    std.debug.print("Пользователь {d} обладает силой {d}\n", .{user.id, user.power});
}

fn levelUp(user: User) void {
    user.power += 1;
}

pub const User = struct {
    id: u64,
    power: i32,
};
```

Ладно, это была грубая уловка... Эта программа ничего не выведет,
потому что она просто не откомпилируется:

```
src/ex-ch04-01.zig:16:16: error: cannot assign to constant
    user.power += 1;
    ~~~~~~~~~~~^~~~
```

Мы уже знаем из главы 1, что параметры функций являются константами
и поэтому инструкция `user.power += 1;` некорректна. Чтобы исправить
эту ошибку компиляции, мы могли бы написать что-то вроде

```zig
fn levelUp(user: User) void {
    var u = user;
    u.power += 1;
}
```
Теперь программа успешно откомпилируется, но она напечатает вот это:

```
$ /opt/zig-0.11/zig run src/ex-ch04-02.zig 
Пользователь 1 обладает силой 100
```

Мы вроде как хотели увеличить силу пользователя на единицу,
но она осталась равной изначальной, то есть 100. Почему так происходит?
Чтобы понять, полезно думать о данных с точки зрения их размещения
в памяти или, выражаясь иначе, думать о переменных как о ярлычках,
которые связывают значение переменной с каким-то конкретным местом
в памяти. Например, в функции `main` мы создаём экземпляр структуры `User`.
Простой визуализацией этих данных в памяти может служить такая картинка:

```
user -> ------------ (id)
        |    1     |
        ------------ (power)
        |   100    |
        ------------
```

Здесь нужно отметить две важные вещи. Первая - переменная `user` показывает
на начало структуры. Вторая - поля располагаются последовательно друг за другом.
У переменной `user` также есть тип, который говорит нам о том,
что поле `id` это 64-битное целое, а поле `power` это тоже целое размером 32 бита.
Вооруженный ссылкой на начало структуры и типом, компилятор может
перевести `user.power` примерно так - "получить доступ к 32-х битному целому,
расположенному по смещению 64 бита от начала структуры". В этом мощь переменных,
они всегда отсылают к какому-то месту в памяти и включают в себя информацию
о типе, для того, чтобы можно было манипулировать содержимым памяти
осмысленным образом.

По умолчанию Zig не гарантирует какое-то конкретное расположение полей
структуры в памяти - он может расположить их в алфавитном порядке,
в порядке увеличения размера, при этом, возможно, с пустыми промежутками.
Он может делать всё что угодно, при условии, что он сгенерирует правильный
машинный код. Такая свобода позволяет осуществлять некоторые оптимизации.
Мы можем получить строгие гарантии расположения только если объявим
так называемую упакованную структуру (`packed struct`). Тем не менее,
наша визуализация переменной `user` вполне разумна и полезна.

Вот несколько иная визуализация, тут включены адреса ячеек памяти:

```
user ->   ------------  (id: 1043368d0)
          |    1     |
          ------------  (power: 1043368d8)
          |   100    |
          ------------
```

Тут адрес начала это просто какое-то условное число.
Имея его и зная размеры полей, мы знаем адреса всех полей.
В данном случае, поскольку размер поля `id` равен 8-ми байтам,
поле `power` имеет адрес, равный адресу начала структуры плюс 8.

Чтобы Вы могли сами в этом убедиться, мы сейчас введём оператор взятия
адреса, он обозначается символом `&`. Как подразумевает название
этого оператора, он возвращает адрес переменной (а также может
возвращать адрес функции, то есть адрес, где начинается
код функции). Не меняя существующее определение `User`, попробуйте
вот такую `main`:

```zig
pub fn main() void {
    var user = User{
        .id = 1,
        .power = 100,
    };
    std.debug.print("{*}\n{*}\n{*}\n", .{&user, &user.id, &user.power});
}
```
Этот код печатает адреса `user`, `user.id` и `user.power`:

```
$ /opt/zig-0.11/zig run src/ex-ch04-03.zig 
ex-ch04-03.User@7ffdb6cad4d8
u64@7ffdb6cad4d8
i32@7ffdb6cad4e0

```
В зависимости от Вашей аппаратной платформы, а также от ряда других
факторов, Вы можете увидеть не конкретно такие числа, но это не важно.
Важно то, что адреса `user` и его первого поля `user.id` одинаковы,
а адрес 2-го поля ровно на 8 байт больше.

Оператор взятия адреса возвращает *указатель* на значение.
Это другой тип, не такой же, как у самого значение.
Указатель на значение типа `T` пишется как `*T`.
Следовательно, когда мы берём адрес переменной `user`, он будет иметь тип `*User`,
то есть указатель на `User`:

```zig
pub fn main() void {
    var user = User{
        .id = 1,
        .power = 100,
    };

    const user_ptr = &user;
    std.debug.print("{any}\n", .{@TypeOf(user_ptr)});
}
```

Нашей изначальной целью было увеличение силы пользователя на единицу,
посредством вызова функции `levelUp`. Мы добились успешной компиляции,
но когда мы печатали значение `user.power`, мы видели, что оно
у нас после вызова `levelUp` не изменилось. А давайте напечатаем
адреса обеих наших переменных `user`, той, что в `main` и той, что в `levelUp`:

```zig
pub fn main() void {
    const user = User{
        .id = 1,
        .power = 100,
    };

    // added this
    std.debug.print("main: {*}\n", .{&user});

    levelUp(user);
    std.debug.print("Пользователь {d} обладает силой {d}\n", .{user.id, user.power});
}

fn levelUp(user: User) void {
    // add this
    std.debug.print("levelUp: {*}\n", .{&user});
    var u = user;
    u.power += 1;
}
```

Если Вы это запустите, то увидите совершенно разные адреса:

```
$ /opt/zig-0.11/zig run src/ex-ch04-05.zig 
main: ex-ch04-05.User@20cfb0
levelUp: ex-ch04-05.User@7ffc8e852798
```

Это означает, что `user`, который подвергается модификации
внутри `levelUp` это совсем не тот `user`, который фигурирует в `main`.
Так получается потому, что в функцию `levelUp` передаётся *копия*
значения. Это может показаться странным умолчанием, но одно из преимуществ
такого поведения состоит в том, что на вызывающей стороне мы абсолютно
уверены, что вызываемая функция ничего не поменяет, потому что попросту не может
этого сделать. Во многих случаях весьма полезно иметь такую гарантию,
но иногда (как в нашем примере с `levelUp`) мы-то как раз *хотим*
изменить силу пользователя и чтобы этого добиться, мы должна сделать
так, чтобы эта функция работала именно с той областью памяти,
где располагается `user`, который в `main`, а не с его копией.
Мы это можем сделать, если передадим в `levelUp` *адрес* переменной `user`:

```zig
const std = @import("std");

pub fn main() void {
    var user = User{
        .id = 1,
        .power = 100,
    };

    // user -> &user
    levelUp(&user);
    std.debug.print("Пользователь {d} обладает силой {d}\n", .{user.id, user.power});
}

// User -> *User
fn levelUp(user: *User) void {
    user.power += 1;
}

pub const User = struct {
    id: u64,
    power: i32,
};
```

Нам пришлось сделать два изменения:

* при вызове `levelUp` мы передаём адрес переменной `user`, то есть `&user`
* при определении `levelUp` мы написали `levelUp(user: *User)`, то есть теперь эта функция принимает указатель на структуру `User`

Теперь наш код работает в точности так, как мы задумывали:

```
$ /opt/zig-0.11/zig run src/ex-ch04-06.zig 
Пользователь 1 обладает силой 101
```

Есть ещё много тонкостей при передаче параметров в функции
и с нашей моделью памяти в целом, но тем не менее, мы уже
значительно продвинулись. Тут хороший момент отметить,
что всё это не является какой-то специфической особенностью именно Zig.
Модель, которую мы исследуем, является наиболее общей, просто
многие языки могут скрывать детали, тем самым лишая разработчика
некоторой гибкости.

## Методы

До этого мы всё время оформляли нашу `levelUp` как "саму по себе".
Но более чем вероятно, что в реальном коде эта функция будет
оформлена как метод структуры, то есть;

```zig
pub const User = struct {
    id: u64,
    power: i32,

    fn levelUp(user: *User) void {
        user.power += 1;
    }
};
```

Это вызывает вопрос - как нам вызывать метод, у которого параметр
это указатель (`*User` в нашем примере)? Может, надо писать что-то вроде
`&user.levelUp()`? На самом деле, можно вызывать такой метод обычным образом,
то есть `user.levelUp()`. Компилятор понимает, что методу нужен указатель
и передаёт значение по ссылке, то есть так, как нам и надо.

Отдельно стоящая функция использовалась только потому,
что это более явно и легче понять.

## Немутабельные параметры функций

## Указатель на указатель

## Вложенные указатели

## Рекурсивные структуры
